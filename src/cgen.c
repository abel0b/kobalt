#include "kobalt/cgen.h"
#include "kobalt/error.h"
#include "kobalt/options.h"
#include "kobalt/memory.h"
#include "kobalt/uid.h"
#include "kobalt/cmdcc.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TAB "    "

struct kbcgenctx {
    struct kbsrc* src;
    char* headerpath;
    FILE* cheader;
    char* sourcepath;
    char* include;
    FILE* csource;
};

void emit(FILE* file, char * fmt, ...) {
    va_list args;
    va_start(args, fmt);
    vfprintf(file, fmt, args);
    va_end(args);
} 

static int cgen_aux(struct kbastvisitor * astvisitor) {
    struct kbnode* node = kbast_getnode(astvisitor->ast, astvisitor->cur.nid);
    struct kbcgenctx* cgenctx = astvisitor->ctx;

    switch(node->kind) {
        case NFile:
            break;
        case NFun:
            {
                char* name = kbast_getnode(astvisitor->ast, node->data.fun.id)->data.id.name;
                if (strcmp(name, "main") == 0) {
                    emit(cgenctx->csource, "int main() {\n");
                    emit(cgenctx->csource, TAB "printf(\"Hello world!\\n\");\n");
                    emit(cgenctx->csource, TAB "return 0;\n");
                    emit(cgenctx->csource, "}\n");
                }
            }
            break;
        case NFunParam:
            break;
        case NFunParams:
            break;
        case NFunBody:
            break;
        case NDecl:
            break;
        case NType:
            break;
        case NExpr:
            break;
        case NTerm:
            break;
        case NBinExpr:
            break;
        case NStrLit:
            break;
        case NIntLit:
            break;
        case NFloatLit:
            break;
        case NCharLit:
            break;
        case NCall:
            break;
        case NAssign:
            break;
        case NId:
            break;
        case NCallParams:
            break;
        case NCallParam:
            break;
    }
    return 1;
}

void kbcgenctx_new(struct kbopts* opts, struct kbsrc* src, struct kbcgenctx* cgenctx) {
    cgenctx->src = src;
    int lencwd = strlen(opts->cwd);
    int lencachedir = strlen(opts->cachedir);
    int srcsize = lencwd + 1 + lencachedir + 1 + strlen(src->filename);
    
    cgenctx->headerpath = kbmalloc(sizeof(char) * srcsize);
    cgenctx->sourcepath = kbmalloc(sizeof(char) * srcsize);
    
    sprintf(cgenctx->headerpath, "%s/%s/", opts->cwd, opts->cachedir);
    int i;
    cgenctx->headerpath[lencwd] = '/';
    cgenctx->include = &cgenctx->headerpath[lencwd + 1 + lencachedir + 1];
    for(i = 0; i<(int)strlen(src->filename)-3; i++) {
        cgenctx->headerpath[lencwd + 1 + lencachedir + 1 + i] = (src->filename[i] != DS)? src->filename[i] : '.';
    }
    cgenctx->headerpath[lencwd + 1 + lencachedir + 1 + i] = '.';
    cgenctx->headerpath[lencwd + 1 + lencachedir + 1 + i + 1] = 'h';
    cgenctx->headerpath[lencwd + 1 + lencachedir + 1 + i + 2] = '\0';
    cgenctx->cheader = fopen(cgenctx->headerpath, "w");
   
    strcpy(cgenctx->sourcepath, cgenctx->headerpath);
    cgenctx->sourcepath[lencwd + 1 + lencachedir + 1 + i + 1] = 'c';
    cgenctx->csource = fopen(cgenctx->sourcepath, "w");
}

void kbcgenctx_del(struct kbcgenctx* cgenctx) {
    fclose(cgenctx->cheader);
    fclose(cgenctx->csource);
    kbfree(cgenctx->headerpath);
    kbfree(cgenctx->sourcepath);
}

int kbcgen(struct kbopts* opts, struct kbsrc* src, struct kbast* ast) {
    struct kberrvec errvec = kberrvec_make();
    
    struct kbcgenctx cgenctx;
    kbcgenctx_new(opts, src, &cgenctx);

    struct kbastvisitor astvisitor;
    kbastvisitor_new(ast, &cgenctx, cgen_aux, &astvisitor);
    

    emit(cgenctx.cheader, "// This file was generated by kbc v%s\n", KBVERSION);
    
    char* headername = kbmalloc(sizeof(char) * (strlen(src->basename) + 2 + 8 + 1));
    memset(headername, 0, sizeof(char) * (strlen(src->basename) + 2 + 8 + 1));
    {
        int cur = 0;
        for(int ii = 0; ii < (int)strlen(src->basename)-3; ++ii) {
            if (src->basename[ii] >= 'a' && src->basename[ii] <= 'z') {
                headername[cur++] = src->basename[ii] + 'A' - 'a';
            }
            else if ((src->basename[ii] >= 'A' && src->basename[ii] <= 'A') || (src->basename[ii] >= '0' && src->basename[ii] <= '9')) {
                headername[cur++] = src->basename[ii];
            }
        }
        headername[cur++] = '_';
        headername[cur++] = '_';
        genuidmaj(headername + cur);
    }

    emit(cgenctx.cheader, "#ifndef __KBH__%s\n", headername);
    emit(cgenctx.cheader, "#define __KBH__%s\n", headername);
    emit(cgenctx.cheader, "#include <stdlib.h>\n");
    emit(cgenctx.cheader, "#include <stdio.h>\n");
    emit(cgenctx.cheader, "#include <stdbool.h>\n");
    emit(cgenctx.cheader, "#include <stdint.h>\n");
    emit(cgenctx.cheader, "#include <math.h>\n");
    kbfree(headername);
    
    emit(cgenctx.csource, "// This file was generated by kbc v%s\n", KBVERSION);
    emit(cgenctx.csource, "#include \"%s\"\n", cgenctx.include);
    emit(cgenctx.csource, "\n");
    
    kbastvisitor_run(&astvisitor);
   
    emit(cgenctx.cheader, "#endif\n");
    
    fflush(cgenctx.cheader);
    fflush(cgenctx.csource);
    
    
    char* exe = kbmalloc(sizeof(cgenctx.src->basename[0]) * (strlen(cgenctx.src->basename) + 1 + 1));
    strcpy(exe, cgenctx.src->basename);
    int lenbasename = strlen(cgenctx.src->basename);
    for(int i = 0; i < lenbasename; ++ i) {
        if (exe[lenbasename-1-i] == '.') {
#if WINDOWS
            sprintf(&exe[lenbasename - i], "exe", cgenctx.src->basename);
#else
            exe[lenbasename - 1 - i] = '\0';
#endif
            break;
        }
    }

    kbcmdcc_compile(&opts->cmdcc, cgenctx.sourcepath, exe);
    
    kbfree(exe);

    kbastvisitor_del(&astvisitor);
    kberrvec_del(&errvec);    
    kbcgenctx_del(&cgenctx);
    return 1;
}
